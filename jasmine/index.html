<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JS401 Intro to Unit Testing with Jasmine</title>

		<meta name="description" content="This workshop will provide an introduction to Test Driven Development, specifically in the Behavior Driven Development style, using Jasmine.">
		<meta name="author" content="Girl Develop It San Francisco">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/gdilight.css" id="theme">

		<!-- For syntax highlighting -->
		<!-- light editor --><link rel="stylesheet" href="lib/css/light.css">
		 <!-- dark editor<link rel="stylesheet" href="lib/css/dark.css"> -->

		<!-- If use the PDF print sheet so students can print slides-->

		<link rel="stylesheet" href="css/print/pdf.css" type="text/css" media="print">
		<link rel="icon" type="image/x-icon" href="favicon.ico" />
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

		        <!-- Opening -->
				<section>
					<h1>JS401</h1>
					<h3>Intro to Unit Testing with Jasmine</h3>
					<p>
						<small>Slides: <a href ="http://www.teaching-materials.org/jasmine">http://www.teaching-materials.org/jasmine</a></small>
					</p>
				</section>

		        <!--  High level overview of testing, TDD, and BDD -->
				<section>
					<h2>Testing Overview</h2>
					<br>
					<h3>Unit Tests</h3>
					<p><strong>Unit Tests </strong> verify that a relatively small piece of code is doing what it is intended to do. They are narrow in scope and do not check outside systems.</p>
					<br>
					<p>This workshop focuses on Unit Tests</p>

					<!-- Speaker notes -->
					<aside class="notes">
						Sources:
						http://www.tutorialspoint.com/software_testing/software_testing_qa_qc_testing.htm
						http://stackoverflow.com/questions/5357601/whats-the-difference-between-unit-tests-and-integration-tests
					</aside>
				</section>
				<section>
					<h2>Testing Overview</h2>
					<br>
					<h3>Integration Tests</h3>
					<p>Integration Tests – demonstrate that different pieces of the system work together.</p>
				</section>
				<section>
					<h2>Testing Overview</h2>
					<br>
					<h3>QA Tests</h3>
					<p>QA Tests – product-oriented tests that focus on identifying "bugs" in software from the perspective of users. May be automated or manual.</p>
				</section>
				<section>
					<h2>Testing Overview</h2>
					<br>
					<h3>Regression Tests</h3>
					<p>Regression Tests – product-oriented tests that make sure that new changes do not break mission-critical functionality that has already been built (logging in/out, checkout out).</p>
				</section>
				<section>
					<h2>Why test?</h2>
				</section>
				<section>
					<h3>A Common Practice</h3>
					<br>
					<p>You may be familiar with the following steps:</p>
					<ol>
						<li>Write code</li>
						<li>Manually test outcomes</li>
					</ol>
					<br>
					<br>
					<p>This can be useful when you're trying to learn the basics, move quickly, and prototype.</p>
				</section>
				<section>
					<h3>A Common Perception</h3>
					<br>
					<p>Sometimes, it can feel "slower" to write tests.</p>
				</section>
				<section>
					<h3>But consider...</h3>
					<br>
					<p>Projects can live a long time</p>
					<p class="fragment">Code bases can get big</p>
					<p class="fragment">Developer come and go</p>
					<p class="fragment">Time required for manually testing adds up</p>
					<p class="fragment">"upgrades" and "bug fixes" can break other features</p>
				</section>
				<section>
					<h3>Code is for humans</h3>
					<h4>(and so are the bugs)</h4>
					<ul>
						<li>set expectations</li>
						<li>think through the steps</li>
						<li>break down the pieces</li>
						<li>ensure ease of upgrades and deprecations</li>
					</ul>
				</section>
				<section>
					<h3>Benefits of testing</h3>
					<ul>
						<li>shorten feedback loop</li>
						<li>prevent regressions</li>
						<li>document code</li>
					</ul>

					<!-- Speaker notes -->
					<aside class="notes">
						Give an example of writing too much code before testing and not knowing exactly where things went wrong. 

						Give an example of upgrading a "feature" or "bug" only to find out that you broke some key functionality on your website. 

						Give an example of being new to a code base and getting to read the tests to understand how the functions are supposed to fit together. 

						Tests can help new developers have more confidence that their changes are not going to break an application.
					</aside>
				</section>
				<section>
					<h3>What to test</h3>
					<ul>
						<li><strong>inputs/outputs</strong> – when something goes into a function, what should come out?</li>
						<li><strong>"side effects"</strong> – when a function executes, what will change outside of the function?</li>
					</ul>
					<pre><code>
window.bees = 200;

function collectHoney(honeyBucket){ // input honeyBucket
	window.bees = 0; // side effect occurs outside function
	return honeyBucket++; // output
};
					</code></pre>
				</section>
				<section>
					<h3>What is TDD?</h3>
					<br>
					<p><strong>Test-driven Development (TDD)</strong> is an approach to programming.</p>
					<br>
					<ol>
						<li>Write an automated (failing) test. This test will describe the desired behavior</li>
						<li>Write a small amount of code that will make the test pass</li>
						<li>Repeat</li>
					</ol>
				</section>
				<section>
					<h3>A Note to the Purists</h3>
					<p><strong>TDD</strong> recommends tests first before any code.</p>
					<br>
					<p class="fragment">But it's good to remember the <em>reason</em>: maintainable, understandable, reliable code.</p>
					<br>
					<p class="fragment">The most important thing is that you <strong>write tests</strong> – regardless of whether you choose to do so before, during, or after coding.</p>

					<!-- Speaker notes -->
					<aside class="notes">
						Dogma is not the point of this exercise.

						While the theory can sound nice, in reality, it's hard to write all the tests at once beforehand.

						In addition, it is very difficult to write tests for adequate coverage <em>after</em> an entire feature is built.

						Therefore, it's useful to break both test writing and coding up in achievable chunks.

						It's also good to remember that it takes practice to become comfortable with this skill.
					</aside>
				</section>
				<section>
					<h3>What is BDD?</h3>
					<br>
					<p><strong>Behavior-driven Development (BDD)</strong> emerged out of TDD as an approach to programming that considers both business and technical needs.</p>
					<br>
					<p>From the developer perspective, BDD is a style of TDD that uses English in a natural way to describe expected behavior.</p>
				</section>
				<section>
					<h3>BDD patterns</h3>
					<br>
					<p>In this workshop, we will be using the following pattern:
						<pre><code>Describe "a part of an application"
	It "should do something specific"
</code></pre>
					</p>
					<br>
					<p>So you might have something like this:
						<pre><code>Describe "a cat trampoline"
	It "should have a place for a cat to jump"
	It "should not be large enough for a person"
	It "should make cats happy"
</code></pre>
					</p>
				</section>
				<section>
					<h3>Exercise time</h3>
					<br>
					<p><a href="step0/instructions.html" target="_blank">Click here for directions</a></p>
					<p>Suggested time: 10 minutes</p>
				</section>


				<!-- Jasmine Part 1 -->
				<section>
					<h2>Jasmine</h2>
				</section>
				<section>
					<h3>What is Jasmine?</h3>
					<br>
					<blockquote>Jasmine is a behavior-driven development framework for testing JavaScript code.  It does not depend on any other JavaScript frameworks.</blockquote>
					<br>
					<p><a href="http://jasmine.github.io/2.0/introduction.html" target="_blank">Jasmine 2.0 Docs</a></p>
				</section>
				<section>
					<h3>Setting up the Spec Runner</h3>
					<p>In this workshop, we'll be running our tests in a browser from a file called <code>SpecRunner.html</code>. That means, we need to make sure our files are loaded before we write tests. Here's how:</p>
					<pre><code>&lt;!-- include jasmine library --&gt;
&lt;link rel="stylesheet" type="text/css" href="lib/jasmine.css"&gt;
&lt;script type="text/javascript" src="lib/jasmine.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="lib/jasmine-html.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="lib/boot.js"&gt;&lt;/script&gt;

&lt;!-- include source files here... --&gt;
&lt;script type="text/javascript" src="src/App.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="src/Game.js"&gt;&lt;/script&gt;

&lt;!-- include spec files here... --&gt;
&lt;script type="text/javascript" src="spec/GameSpec.js"&gt;&lt;/script&gt;</code></pre>
				</section>
				<section>
					<h3>Suites, specs, and matchers</h3>
<pre><code>// Suites start with the keyword "describe"
describe("A suite", function(){

  // Specs start with the keyword "it"
  it("contains spec with an expectation", function(){

    // expect() statements have matchers like toBe()
    expect(true).toBe(true);

  });
});
</code></pre>
				</section>
				<section>
					<h3><code>toBe()</code> or <code>not.toBe()</code></h3>
					<p>There are special functions called <strong>matchers</strong> that will compare an actual value with an expected value.</p>
					<br>
					<p>You can also add a <code>.not()</code> to your matcher:</p>
					<pre><code>expect(true).not.toBe(false);</code></pre>
					<br>
					<p>Here are some <a href="http://jasmine.github.io/2.0/introduction.html#section-Matchers" target="_blank">other matchers</a> that are built-in:</p>
<pre><code>.toBeDefined();
.toEqual(); // strict equality
.toMatch(); // for regular expressions
.toContain(); // find an item in an array
</code></pre>
				</section>
				<section>
					<h3>A pattern for executing tests</h3>
					<br>
					<ul>
						<li>Set up the stage</li>
						<li>Let the players play their parts</li>
						<li>Tear down the stage</li>
					</ul>
				</section>
				<section>
					<h3>Set up and Tear down</h3>
					<p>Often, you'll run tests with the same set up and tear down procedures. For that, we can use the <code>beforeEach()</code> and <code>afterEach()</code> functions:</p>
					<pre><code>describe("a self-driving car", function(){
  describe("turning in traffic", function(){
    beforeEach(function(){
      startEngine();
      navigate("Safeway");
    });

    afterEach(function(){
      navigate("Home");
      killEngine();
    });

    it("should signal when turning", function(){
      turnLeft();
      expect(leftSignalPosition).toEqual("on");
    });
  });
});
					</code></pre>
					<p><a href="http://jasmine.github.io/2.0/introduction.html#section-Setup_and_Teardown" target="_blank">more from the docs</a></p>
				</section>
				<section>
					<h3>Exercise time</h3>
					<br>
					<p><a href="step1/instructions.html" target="_blank">Click here for directions</a></p>
					<p>Suggested time: 30 minutes</p>
				</section>

				<!-- Jasmine Part 2 -->
				<section>
					<h3>Control Flow</h3>
					<br>
					<p><strong>Control Flow</strong> is the order in which the individual statements, instructions or function calls are executed or evaluated.</p>
				</section>
				<section>
					<h3>Control Flow Example</h3>
					<h4>Filtering, Sorting, and Rendering</h4>
					<img src="./images/book_collection.png">
				</section>
				<section>
					<h3>Control Flow Example</h3>
					<h4>In words</h4>
					<br>
					<pre><code>Describe "a book collection"
  It should sort based on the "sort by" field
  It should sort by author's last name if "sort by" field is empty
  It should call sort whenever a user selects "filter by"
  It should re-render the collection after sort</code></pre>
				</section>
				<section>
					<h3>Testing Control Flow</h3>
					<br>
					<p>Control flow can get complicated, and it becomes tricky to test all the possible scenarios manually.</p>
					<br>
					<p>Therefore, it's useful to break up the pieces and write unit tests for each piece.</p>
				</section>
				<section>
					<h3>Spies</h3>
					<br>
					<p>Spies can test the control flow of an application by:</p>
					<br>
					<ul>
						<li>stubbing a function</li>
						<li>tracking calls to a function</li>
						<li>exposing arguments that a function was called with</li>
					</ul>
				</section>
				<section>
					<h3>Using Spies</h3>
					<ul>
						<li>spies are usually called on Object methods</li>
						<li>spies have their own matchers such as <code>toHaveBeenCalled()</code>, <code>toHaveBeenCalledWith()</code>, <a href="http://jasmine.github.io/2.0/introduction.html#section-Spies" target="_blank">and more!</a></li>
					<pre><code>describe("a robot sidewalk sweeper", function(){
  it("should look left before crossing the street", function(){
    spyOn(robot, 'lookLeft'); // set up the spy
    robot.crossStreet(); // execute

    // use matchers to see if the function was called
    expect(robot.lookLeft).toHaveBeenCalled();
    expect(robot.lookLeft.calls.count()).toBeGreaterThan(1);
  });
});</code></pre>
				</section>
				<section>
					<h3>Tracking Spies</h3>
					<br>
					<p>Function calls to spies are tracked through the <code>calls</code> property.</p>
					<pre><code>expect(robot.lookLeft.calls.count()).toBeGreaterThan(1);</code></pre>
					<br>
					<p><a href="http://jasmine.github.io/2.0/introduction.html#section-Other_tracking_properties" target="_blank">Read more about it here!</a></p>
				</section>
				<section>
					<h3>Exercise time</h3>
					<br>
					<p><a href="step2/instructions.html" target="_blank">Click here for directions</a></p>
					<p>Suggested time: 45 minutes</p>
				</section>

				<!-- End -->
				<section>
					<h2>Automation</h2>
					<ul>
						<li>Running your tests in the browser is helpful as you're developing, but automation will help you run all of the project's tests</li>
						<li>Automation is useful as part of the "build" or "continuous integration" process – that means that code needs to pass all the tests before a merge</li>
						<li>Automation tooling is particular to your technology stack and deploy process</li>
					</ul>

					<!-- Speaker notes -->
					<aside class="notes">
						It also may be worthwhile to mention that automated tests are also applicable to serverside JS testing
					</aside>
				</section>
				<section>
					<h2>Conclusion</h2>
					<ul>
						<li>Some things are hard to test, so get creative</li>
						<li>Practice, practice, practice</li>
					</ul>
				</section>
			</div>
  		<footer>
        <div class="copyright">
          JS401 Intro to Unit Testing with Jasmine -- San Francisco --
          <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/80x15.png" /></a>
        </div>
      </footer>
		</div>


		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
